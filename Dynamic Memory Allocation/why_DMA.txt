When we write int arr[n]; in 'C' and take n as input, this is called 
a Variable Length Array (VLA). VLAs are allocated on the stack, 
which is usually small, so if n is very large, the program may crash 
or cause a segmentation fault. Additionally, not all compilers 
support VLAsâ€”for example, GCC and Clang support them from C99 onwards,
but MSVC does not. This can cause differences in behavior across systems.
For larger arrays or to ensure portability, we use malloc(), which 
allocates memory on the heap. The heap is much larger, so large arrays 
can be handled safely, and memory can be freed using free() to avoid 
memory leaks. Therefore, VLAs are fine for small arrays, but for large 
arrays or portable programs, using malloc() is the best practice.


*Calloc : In C, calloc() is used to allocate memory dynamically
on the heap, similar to malloc(), but with two key differences. 
First, it takes two arguments: the number of elements and the size of 
each element. Second, unlike malloc(), calloc() initializes all allocated 
memory to zero, which can help prevent garbage values in arrays or 
structures. This makes it useful when you need a clean, zero-initialized 
memory block for arrays or matrices.

*Realloc : realloc() is used to resize a previously allocated memory 
block. It can increase or decrease the size of memory allocated by 
malloc() or calloc(). If the new size is larger, realloc() may move 
the memory block to a new location and copy the existing data 
automatically. This is useful when the array size is not known 
initially or needs to grow/shrink during runtime.

*Free : In C, free() is used to deallocate memory that was previously 
allocated dynamically using malloc(), calloc(), or realloc(). 
When you allocate memory on the heap, it stays reserved until the 
program ends or you explicitly free it. Failing to free memory leads 
to memory leaks, which can slow down or crash programs, especially in 
long-running applications. After calling free(), the pointer itself 
still exists but the memory it points to is no longer valid, so it is 
a good practice to set the pointer to NULL immediately after freeing 
it to avoid accidental access.